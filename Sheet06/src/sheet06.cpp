#include <iostream>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <string>
#include <iomanip>

using namespace std;

const int NUM_IMAGES=33;
string image_prefix = "images/";
string image_suffix = ".png";
cv::Rect bb_frame1(448,191, 38,33);

//////////////////////////////////////
//////// utility functions ///////////
//////////////////////////////////////
string fixedLenString(int i,int len, string prefix, string suffix){
    stringstream ss;
    ss << setw(len) << setfill('0') << i;
    string s = ss.str();
    return prefix+s+suffix;
}

template < class T >
ostream& operator << (ostream& os, const vector<T>& v)
{
    os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii)
    {
        os << " " << *ii;
    }
    os << "]";
    return os;
}

void calculateHistogram(cv::Mat &img, cv::Mat &hist, cv::Rect &bb) {
    cv::Mat t(img, bb);
    cv::Mat img_hsv;
    cv::cvtColor(t, img_hsv, cv::COLOR_BGR2HSV);

    int h_bins = 256; int s_bins = 256;
    int histSize[] = {h_bins, s_bins};
    float h_ranges[] = { 0, 180 };
    float s_ranges[] = { 0, 256 };
    const float* ranges[] = { h_ranges, s_ranges };
    int channels[] = { 0, 1 };

    cv::calcHist(&img_hsv, 1, channels, cv::Mat(), hist, 2, histSize, ranges);
}

//////////////////////////////////////
/// class declarations for task 3 ////
//////////////////////////////////////
class Particle{
public:
    Particle(){fitness=0;};
    Particle(cv::Mat& img, cv::Rect& bb, cv::Mat& refhist, const cv::Point2i off);  // present frame, sampled bb from previous frame, refhist and offset from motion model
    ~Particle() = default;;
    cv::Rect bb;
    cv::Mat hist;
    float fitness{};
    void measureFitness(const cv::Mat& refhist);    // evaluates fitness for the present particle given refhist
};

Particle::Particle(cv::Mat &img, cv::Rect &bb, cv::Mat &refhist, const cv::Point2i off) {
    this->bb = bb + off;
    calculateHistogram(img, this->hist, this->bb);
    this->measureFitness(refhist);
}

void Particle::measureFitness(const cv::Mat &refhist) {
    this->fitness = (float) cv::compareHist(refhist, this->hist, CV_COMP_BHATTACHARYYA);
}

class ParticleFilter{
public:
    ParticleFilter(){numptl=200; mu_x=0; mu_y=0; particles.resize(numptl); cumulFit.resize(numptl);};
    ~ParticleFilter(){};
    void init(cv::Mat& img, cv::Rect& bb);      // input is the reference frame and bounding box. Initialize the histogram refhist here
    void track(cv::Mat& img);                   // samples particles from previous frame, applies motion model and then calculates fitness of each particle
    void showParticles(cv::Mat& img);           // function to show the particles of the current frame (already given)

    int numptl;                     // number of particles
    float mu_x, mu_y, mu_decay, sigma;                // motion model: offset_x and offset_y are generated by a 1d gaussian (mean: [mu_x, mu_y], std: sigma)
                                                      // mu_decay controls the evolution of mu
    vector<float> cumulFit;         // vector to hold the cumulative fitness
    vector<Particle> particles;
    cv::Mat refhist;                 // holds the reference color histogram for evaluating fitness of particles from further frames
private:
    void evaluateCumulFeat();       // computes cumulative fitness distribution and populates cumulFit
    int sampleParticle();
    cv::Rect applyMotionModel(const cv::Rect& bb);
    cv::RNG rng;                     // random number generator for offsets, sampling etc.
};

void ParticleFilter::showParticles(cv::Mat& img){
    cv::Mat show=img.clone();
    for(int pid=0; pid<numptl; ++pid){
        cv::rectangle(show,particles[pid].bb,cv::Scalar(0,0,255*particles[pid].fitness),1);

    }
    cv::imshow("tracked",show);
    cv::waitKey(100);
}

void ParticleFilter::init(cv::Mat &img, cv::Rect &bb) {
    calculateHistogram(img, this->refhist, bb);
}

void ParticleFilter::track(cv::Mat &img) {
    this->showParticles(img);
}

void ParticleFilter::evaluateCumulFeat() {

}

int ParticleFilter::sampleParticle() {
    return 0;
}

cv::Rect ParticleFilter::applyMotionModel(const cv::Rect &bb) {
    return cv::Rect();
}

////////////////////////////////////
// 1 and 2 are theoretical tasks ///
////////////////////////////////////

int main(int argc, char* argv[])
{

     ParticleFilter pf;

    for(int i=1; i<NUM_IMAGES; i++){
        string fname=fixedLenString(i,2,image_prefix,image_suffix);
        std::cout << "File: " << fname << std::endl;
        cv::Mat img=cv::imread(fname);
        cv::imshow("frame",img);
        cv::waitKey(100);
        if(i==1) pf.init(img, bb_frame1);
        else pf.track(img);
    }

    std::cout << CV_VERSION << std::endl;

    cout <<                                                                                                   endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////    END    /////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout <<                                                                                                   endl;

}
