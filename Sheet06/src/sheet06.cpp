#include <iostream>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <string>
#include <iomanip>

using namespace std;

const int NUM_IMAGES=33;
string image_prefix = "images/";
string image_suffix = ".png";
cv::Rect bb_frame1(448,191, 38,33);

//////////////////////////////////////
//////// utility functions ///////////
//////////////////////////////////////
string fixedLenString(int i,int len, string prefix, string suffix){
    stringstream ss;
    ss << setw(len) << setfill('0') << i;
    string s = ss.str();
    return prefix+s+suffix;
}

template < class T >
ostream& operator << (ostream& os, const vector<T>& v)
{
    os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii)
    {
        os << " " << *ii;
    }
    os << "]";
    return os;
}

//////////////////////////////////////
/// class declarations for task 3 ////
//////////////////////////////////////
class Particle{
public:
    Particle(){fitness=0;};
    Particle(cv::Mat& img, cv::Rect& bb, cv::Mat& refhist, const cv::Point2i off);  // present frame, sampled bb from previous frame, refhist and offset from motion model
    ~Particle(){};
    cv::Rect bb;
    cv::Mat hist;
    float fitness;
    void measureFitness(const cv::Mat& refhist);    // evaluates fitness for the present particle given refhist
};

class ParticleFilter{
public:
    ParticleFilter(){numptl=200; mu_x=0; mu_y=0; particles.resize(numptl); cumulFit.resize(numptl);};
    ~ParticleFilter(){};
    void init(cv::Mat& img, cv::Rect& bb);      // input is the reference frame and bounding box. Initialize the histogram refhist here
    void track(cv::Mat& img);                   // samples particles from previous frame, applies motion model and then calculates fitness of each particle
    void showParticles(cv::Mat& img);           // function to show the particles of the current frame (already given)

    int numptl;                     // number of particles
    float mu_x, mu_y, mu_decay, sigma;                // motion model: offset_x and offset_y are generated by a 1d gaussian (mean: [mu_x, mu_y], std: sigma)
                                                      // mu_decay controls the evolution of mu
    vector<float> cumulFit;         // vector to hold the cumulative fitness
    vector<Particle> particles;
    cv::Mat refhist;                 // holds the reference color histogram for evaluating fitness of particles from further frames
private:
    void evaluateCumulFeat();       // computes cumulative fitness distribution and populates cumulFit
    int sampleParticle();
    cv::Rect applyMotionModel(const cv::Rect& bb);
    cv::RNG rng;                     // random number generator for offsets, sampling etc.
};

void ParticleFilter::showParticles(cv::Mat& img){
    cv::Mat show=img.clone();
    for(int pid=0; pid<numptl; ++pid){
        cv::rectangle(show,particles[pid].bb,cv::Scalar(0,0,255*particles[pid].fitness),1);

    }
    cv::imshow("tracked",show);
    cv::waitKey(100);
}

////////////////////////////////////
// 1 and 2 are theoretical tasks ///
////////////////////////////////////

int main(int argc, char* argv[])
{

//     ParticleFilter pf;

    for(int i=1; i<NUM_IMAGES; i++){
        string fname=fixedLenString(i,2,image_prefix,image_suffix);
        cv::Mat img=cv::imread(fname.c_str());
        cv::imshow("frame",img);
        cv::waitKey(100);
////        if(i==1) pf.init(img,fram1_bb,mu_decay,sigma);
////        else pf.track(img);
    }

    cout <<                                                                                                   endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////    END    /////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout << "////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    cout <<                                                                                                   endl;

}
